# 实验二：

## 1、git、gitee、开源学习记录和报告：

一开始，我们用的是git+github

![image-20230306173444546](C:\Users\平凡之路\AppData\Roaming\Typora\typora-user-images\image-20230306173444546.png)

![image-20230306173506905](C:\Users\平凡之路\AppData\Roaming\Typora\typora-user-images\image-20230306173506905.png)

如图所示，我们每个人建立了一个分支，用于上传实验报告和代码，便于整理和协作；

那么其实gitee的操作和github的操作是类似的；

![ad17a40ab473757c683eb1f9b344e45](D:\TEMPFI~1\WeChat Files\ad17a40ab473757c683eb1f9b344e45.png)

![image-20230307170127587](C:\Users\平凡之路\AppData\Roaming\Typora\typora-user-images\image-20230307170127587.png)

如图，我在我的gitee仓库里也建了一个分支

![d46a74de8d774d9e57efa890b324458](D:\TEMPFI~1\WeChat Files\d46a74de8d774d9e57efa890b324458.png)

![5f7045fa87b7fd659f3e25e37a4f2ee](D:\TEMPFI~1\WeChat Files\5f7045fa87b7fd659f3e25e37a4f2ee.png)

![16ac974ed49c524aa89ce599c4eb078](D:\TEMPFI~1\WeChat Files\16ac974ed49c524aa89ce599c4eb078.png)

## 2、MiniOB分析工作进度报告：



**首先，我了解了一下MiniOB的基本框架和基本原理，记录如下：**

## MiniOB：一个有基础功能的小型数据库

### ![img](https://ucc.alicdn.com/pic/developer-ecology/b8bf165b9ffc4f78a745570581d2c870.png)

### 基本框架：

CLIENT向灰框里的服务端发起请求；经过NET网络模块将请求送给Parser模块进行词法解析（LEX）和语法解析（YACC）；解析后，送给Plan Cache模块，当前的Plan Cache不做任何特殊处理；Resolver模块将Parser模块解析出的语法树进行细化；然后Transformer和Optimizer进行优化，不断迭代，尽量找到一个低成本的执行计划；之后传给Executor执行模块，按照执行计划执行查询，执行结果返回给NET网络模块；NET模块通过Socket返回给客户端。

### 存储引擎：

**三个关键性模块：**

Buffer Pool、B+-Tree、Record Manager；

![img](https://ucc.alicdn.com/pic/developer-ecology/91c5d4e91098474d947cd61c3c7b2ff6.png)

MiniOB中文件存放方式：数据库是一个文件，一个目录db/sys；

table文件：源数据表明数据类型、数据索引、字段类别及类型以及每个类型的长度；

data文件：执行记录存放的文件；

index文件：索引名称+后缀名。

**关于Buffer Pool：**

负责管理磁盘数据与内存缓存；

内存分frame，磁盘分page，每个frame对应一个page，读取一个page时，内存若有空闲的frame，则分配给该page，若无空闲frame，但如果内存还有空闲的话，则尝试再申请一个frame，若内存也无空闲，则根据淘汰条件和算法淘汰一个已关联的page。

**关于物理文件的组织结构：**

![img](https://ucc.alicdn.com/pic/developer-ecology/5797ef507e6b41a792a2d9ea2499a6f6.png)

第一页为页头，记录page num页号，page count以及已分配的pages；

**MiniOB的记录管理：**

记录可以为一行数据，记录管理模块主要负责记录磁盘存放方式和格式以及对数据进行增删改查的方法；

record manager进行管理前提：记录通常比较短；记录都是固定长度（不定长呢？）；

**关于代码：**

![img](https://ucc.alicdn.com/pic/developer-ecology/d5bb61c4e2e34dc98dc8d0274900a885.png)

MiniOB里只有一个Free Manager对象，可简单认为是一个链表，里面存放了一系列的内存页帧，页帧可以对应文件以及页号；

读取页面，从已有页面直接找，若没有页面则需要申请一个页面，若需要淘汰，注意写回磁盘；



**其次，我在虚拟机ubuntu上进行了docker+vscode的安装与配置。**

![image-20230307171210272](C:\Users\平凡之路\AppData\Roaming\Typora\typora-user-images\image-20230307171210272.png)

首先，我按照教程在虚拟机上安装了docker；

![4789137c80fb3bdc222e3ca819843a1](D:\TEMPFI~1\WeChat Files\4789137c80fb3bdc222e3ca819843a1.png)

之后，用终端命令下载并运行miniob镜像；

![deaa59ff86c5dbdd4891f1b06500fee](D:\TEMPFI~1\WeChat Files\deaa59ff86c5dbdd4891f1b06500fee.png)

如图，我开启了ID为eab535a240fe的miniob；

![f0789df19d3cf0fbe5f93d8f2452b1a](D:\TEMPFI~1\WeChat Files\f0789df19d3cf0fbe5f93d8f2452b1a.png)

之后，在vscode里就可看到正在运行的容器，然后进入到miniob镜像中去；

![8e316af4acc98ffa1d49009be2b15b6](D:\TEMPFI~1\WeChat Files\8e316af4acc98ffa1d49009be2b15b6.png)

在容器内安装插件；

![29762014e5a816b128a78f80f40f41e](D:\TEMPFI~1\WeChat Files\29762014e5a816b128a78f80f40f41e.png)

创建.vscode，配置tasks.json文件；之后make、cmake，Cmake Build；Run observer以及Run obclient；

![82786ba940ceed9c42250e39994e0d3](D:\TEMPFI~1\WeChat Files\82786ba940ceed9c42250e39994e0d3.png)

之后进行gdb调试，调试也没有出错，至此配置成功。

## 4、

**1.10.1**

毫无疑问，失败的根本原因在于代码复用。但是，造成这种灾难性后果的原因也包括了客户错误地说明了需求，厂商在开发时仅仅是遵循了给定的规格说明，即在检测到任何异常的情况下，处理器将终止执行。异常被检测到了，但并没有被适当处理，这就导致了发射的失败。

改进方案：客户和开发人员要一起工作找出关键软件，并确保它不仅能处理预测到的行为，而且能够处理未预测到的行为。关键软件必须在一个非常详细的层面标识出来，异常行为必须细化，并且一个合理的备份策略必须将软件失效考虑进去。
